# 消息队列

1、为什么使用消息队列，消息队列的优缺点，kafka,activemq, rabbitmq,rocketmq

都有什么区别，适合那些场景

为什么：

​	解耦

​	异步

​	削峰

优缺点：

缺点： 

​	系统可用性降低：

​		MQ故障

​	系统复杂性提高：

​		消息的重复性消费，消息丢失。消息传递的顺序性

​	一致性问题

​		同一份消息，有的消费成功，有的消费失败



2、保证消息队列的高可用

​	rabbitMQ（非分布式）:

​		普通集群模式：

​			只有一个节点拥有元数据和实际数据，其他节点只拥有元数据

​		镜像集群模式：

​			所有节点都拥有所有的数据

​	kafka(分布式的)



3、如何保证消息不被重复消费（如何保证消息的幂等性）？

​	幂等：一条数据出现两次，数据库中只出现了一次，这就保证了幂等性



4、保证MQ消息的可靠性？保证消息不丢失

​	rabbitmq消息丢失：

​		1、写消息的过程中，因为网络传输问题，或其他问题，rabbitMq没保存成功

​			 1.消息事务：是同步的（会阻塞）

​			 2.confirm机制（常用）：

​		2、rabbitMq收到消息，放到内存中，rabbitmq挂了，内存中的数据丢了

​			   开启rabbitMq 持久化

​		3、消费者收到消息，没来得及处理，自己挂了，rabbitmq认为已经处理完了

​				消费者的autoAck 模式（基本不用，自己去确定消息是否处理完）

​	kafka数据丢失：

​		1、写消息的过程中，因为网络传输问题，或其他问题，kafka没保存成功

​			 ask=all ,没条数据写入到所有的replica之后，才能认为是写成功了

​		     retries=MAX(很大的一个值),写入失败，就无限重试

​		2、kafka收到消息，放到leader中，leader没来得及把数据同步到follower，leader挂了,将follwer切换为leader，数据丢失

​				给这个topic设置replication.factor参数：这个值必须大于1，要求每个partition至少要有两个副本 

​		3、消费者收到消息，没来得及处理，自己挂了，kafka认为已经处理完了

​				消费者会自动提交offset,关闭offset，手动提交offset

5、保证消息的顺序性

​		rabbit：一个queue,多个consumer 会出现消息错乱

​				每个消费者一个队列

​		kafka：一个topic，一个partition。一个consumer，内部多线程  错乱

​				多线程处理之前，使用一个内存队列暂存数据，

6、如何解决消息队列延时，过期失效的问题？队列满了的处理方法，积压消息太多，咋办





# redis







1 redis 线程模型

​	基于socket 模型  IO多路复用技术  队列  事件分派器    事件处理器

2、为什么 redis 单线程模型效率高

​	纯内存操作

​	核心是基于非阻塞的IO多路复用技术

​		单线程避免了多线性频繁切换上下文问题



3、redis 过期策略， LRU算法

​	定期删除

​	惰性删除



​	内存淘汰机制：

​		allkeys-Lru(常用)

​		allkeys-random (随机)

4、保证redis 高并发 高可用



redis 不能支持高并发的瓶颈： 是单机的



redis要支撑超过10万+的并发，怎么办

​	读写分离 （读多写少） ： 主从架构



redis Replication: redis 复制





redis 全量复制 ， 增量复制



redis 不可用（主从架构）

​	master node 死了，没办法写数据

redis 高可用（故障转移，主备切换）



sentinal node(哨兵)  作用：

​	集群监控

​	消息通知

​	故障转移

​	配置中心



quorum = 1 , 几个哨兵认为master node 宕机

majority:  大多数哨兵是运行的（多于总哨兵的的一半）

最少quorum  个哨兵认为master宕机了，且 majority个哨兵工作，才可以进行故障转移



redis 数据丢失问题:



redis 脑裂问题：

​	master主节点因为网络问题出现了异常,但实际上master还运行着，哨兵认为主节点宕机了，然后把一个slaveNode 改为master node，这个时候会出现两个 master 



解决异步复制和脑裂造成的数据丢失

​	min-slaves-to-write 1

​	min-slaves-max-lag 10

​	至少有1个slave，数据复制和同步的延迟不能超过10s，

​	如果所有slave。数据复制和同步超过10s，master就不再接收任何请求



sdown（主观宕机）：有一个哨兵认为master宕机

odown（客观宕机）：有quorum数量的哨兵都认为master 宕机





redis cluster（多master  + 读写分离 + 高可用）:

​	可以支撑N个redis master Node ，每个master 可以挂载多个 slave node

​	读写分离架构： 对于每个master，写就写到master， 读从 master对于的slave 中读

​	高可用：如果master挂了，自动将某个slave转换为maseter



redis cluser, replication, sentinal

​	单机： 数据量少

​	replication: 一个master，多个slave，搭建一个sentinal集群，保证架构高可用

​	cluster： 海量数据+高并发+高可用

​	





# 数据结构与算法

线性结构： 数据元素之间存在一一对应的线性关系

非线性结构：



稀疏数组：数组中的大部分元素是同一个值



----------------------------------------------------------------------------------------------------------------------------------

ActiveMQ:

​	

1、服务器宕机了怎么办

​	非持久化消息存在内存中，持久化消息存在文件

​	尽量不要使用非持久化消息，要用，将临时文件尽可能的调大

2、怎么防止丢消息

​	使用持久化消息，

​	非持久化消息及时处理

​	启动事务

3、持久化消息比较慢

​	非持久化消息都是一部发送的，持久化消息是同步发送的

​	开启事务的情况下，消息都是异步发送的，

​	建议开启事务

4、消息不均匀消费

​	prefetch机制：消费者获取消息时，是一次获取prefetch的数量的消息个数

​	prefetch：1

5、怎么设置 消息处理失败，不被服务器删除，还能被其他消费者处理

​		关闭Auto_AcknowLedge，将ack由程序自己处理

​	

# Kafka





# Redis

1、redis 优缺点：

​	redis 是一个 key-value 类型的内存数据库，操作在内存中进行，定期通过异步操作把数据flush到硬盘

​	每秒 10万次读写操作

​	支持多种数据结构， 单个value的最大限制是10G

​	数据库容量受到物理内存的限制，不能用作海量数据的高性能读写

​	适合数据量较小的高性能操作和运算



2、Redis 与 memcached 相比有哪些优势？  

​	mc所有的值均为简单字符串， redis 支持多种数据类型

​	redis的速度比mc 快

​	redis可以持久化数据

3、redis 的淘汰策略：

​	allkeys-Lru（LRU）: 尝试回收最少使用键，

​	volatile-Lru(LRU): 尝试回收最少使用的键，仅限在过期集合的键

​	allkeys-random: 随机回收键

4、redis为什么把数据存放到内存

​	为了最快的读写速度，通过异步的方式将数据写入磁盘，

5、redis的集群方案

​	codis

​	2、

6、Redis 集群方案什么情况下会导致整个集群不可用  

​	A,B,C 三个节点的集群，在没有复制模型的情况下，B挂了，



7、如何保证redis 中的数据都是热点数据

​	redis数据集到达一定的数量时，会实行数据淘汰策略

8、redis 适合的场景

​	会话缓存，队列， 排行榜/计数器, 发布/订阅 

9、 redis的主从复制模型是什么样的？

​	每个节点都有 N-1 个复制品，保证大部分节点挂了，集群仍然可用

10、 redis 事务

​	事务是一个单独的隔离操作，事务中的所有命令都会序列化，顺序执行，

​	事务在执行过程中，不会被其他请求打断

11、redis 的内存优化

​	尽可能的使用散列表，散列表使用的内存很小

12、redis的分布式锁

​	用setnx 抢锁，抢到之后，用expire 给锁设置过期时间

​	应该  把setnx 和expire 合成一条指令运行

13、什么是缓存穿透？如何避免，什么是缓存雪崩？如何避免?

​	缓存穿透：根据key查value。如果故意查询不存在的key，请求量很大，这就叫缓存穿透

​	穿透避免:

​		对查询结果为空的情况也进行缓存

​		对一定不存在的key进行过滤

​	缓存雪崩：缓存服务器重启，或者大量缓存几种在某一个时间段失效，在这段时间，会给后台系统造成很大的压力

​	雪崩避免：

​		缓存服务器失效后，通过加锁或者队列的方式，控制读数据库写缓存的线程数量

​		做二级缓存

​		不同的key，设置不同的过期时间

14、redis和memcached 的区别，为啥高并发下有时单线程的redis比多线程的memcached效率高

​	mc 可以缓存图片和视频，rd支持更多的数据结构

​	rd使用虚拟内存，rd可持久化和aof灾难恢复，rd 通过主从支持数据备份

​	rd可做消息队列

​	mc多线程模型引入了缓存一致性和锁，加锁带来了性能损耗

15、redis持久化，优缺点

​	RDB：在不同时间点将redis的数据生成快照同步到磁盘

​		内存到硬盘的快照，定期更新

​		缺点：耗时，耗性能，易丢失数据

​	AOF：将所有执行过的指令都记录下来，在下次redis重启时，去执行指令  （写日志）

​		缺点：体积大，恢复速度慢

​	rewrite： 可以对aof进行优化

​	bgsave指令，做镜像全量的持久化，aof做增量持久化

​	优先使用aof来恢复内存，没有，使用rdb

16、redis高可用

​		redis 哨兵和复制

​		哨兵：管理redis服务器，提供监控，提醒、自动的故障转移的功能

​		复制：让一个redis服务器可以配备多个备份服务器

17、redis 哨兵的主要功能

​	集群监控

​	消息通知

​	故障转移

​	配置中心

18、redis 哨兵的高可用

​	主节点故障，redis Sentinel 自动完成故障发现和转移，并通知应用方

19、redis 主从复制，哨兵，集群的区别

​	主从：读写分离，备份，一个master 多个slaves

​	哨兵：监控，自动转移

​	集群：将数据分配到多台服务器



# 乐观锁和悲观锁

悲观锁（独占）：资源每次只给一个线程使用，其他线程堵塞，用完释放锁

乐观锁：使用读多写少的情况。提高吞吐量（CAS算法）





# rabbitMq



ActiveMQ

1、activeMQ的通信方式

​	publish/subscribe  发布订阅

​	p2p

2、active消息丢失

​	publish/subscribe

​		接受不到消息就没了

​		不丢失：持久订阅

​	p2p	

​		消息发送不成功保存到active服务器，直到有消费者消费

3、消费者重复消费

​	在业务端加张表，存放消息是否执行成功，消费之前，先判断是否已经消费

# Zookeeper

1、zk是什么

​	zk是分布式应用协调服务，

2、zk的功能

​	文件系统

​	通知机制



3、zk的文件系统

​	为了保证搞吞吐量和低延迟，在内存中维护了树状的目录结构，

​	确定，不能存放大量的数据



CSRF：跨站请求伪造







JAVA

1、面向对象的三大特性

​	封装

​		把对象的属性私有化，提供可被访问的属性方法

​	多态

​		程序中使用的引用变量和引用变量的方法，是在程序运行期间才能确定

​	继承

​		使用已存在的类为基础，创建新的类

2、 == 和 equals

​	==: 判断两个对象的地址是否相等，即判断两个对象是否是同一个对象

​		基本类型 == 比较的是值，引用类型 == 比较的是内存地址

​	equals: 判断两个对象是否相等

​		类没有覆盖equals： 等价 ==

​		类覆盖了equals:  两个对象的内容是否相等

3、内存模型及分区，

​	堆： 对象

​		初始化的对象，成员变量，对象实例和数组

​	栈： 引用

​		栈帧组成，栈帧存储 局部变量，操作数栈，方法出口

​	方法区： 常量池

​		主要存储类信息，常量池，编译后的字节码

​	本地方法栈：

​		Native方法

​	程序计数器：

​		当前线程的执行行号

4、堆里面的分区：eden，survival（from tp），老年代

​	java8 取消了永久代，采用 metaspace

​	新生代：包含eden 和survivor区。survivor区分为 from 和to 

​	老年区：多次Gc后，仍然活着的数据，会进入老年代

​	==jvm内存不够，触发 full gc, 清理老年代==

​	==新生区满了，触发yGC，把活的对象放到survival，进行垃圾清理，一般 把eden 全部清空，整理内存==

5、GC的三种收集算法

​	标记清除：

​		先标记，标记完毕后再清除， 效率不高，会产生碎片

​	标记整理：

​		标记完毕后，让所有的存活对象往一端移动

​	复制算法（YGC）：

​		分为8:1 的eden 区和Sruvivor区

​		先把存活的对象移到survival区，然后进行垃圾清理

6、Minor GC 和full Gc 的发生场景

​	MGC：新生代内存不够用的时候，也叫YGC

​	FGC: jvm内存不够用的时候

7、类的双亲委派机制

​	类加载加载类时，先由它的父亲去加载，如果父类加载不到，再有自己加载

8、什么是类加载器，有哪些类加载器

​	类加载器：通过类的全限定名获取改类的二进制字节流的代码

​	启动类加载器（bootstrap）：

​		加载java核心类库，

​	扩展类加载器（extensions）：

​		加载java扩展类，

​	系统类加载器（system）：

​		根据类路径（classPath）加载java类，java应用的类一般都是由它加载

​		ClassLoader.getSystemClassLoader

​	自定义类加载器

9、java内存分配与回收策略

​	对象优先在eden区分配

​	大对象直接进入老年代

​	长期存活的对象直接进入老年代

​	