# 消息队列

1、为什么使用消息队列，消息队列的优缺点，kafka,activemq, rabbitmq,rocketmq

都有什么区别，适合那些场景

为什么：

​	解耦

​	异步

​	削峰

缺点： 

​	系统可用性降低：

​		MQ故障

​	系统复杂性提高：

​		消息的重复性消费，消息丢失。消息传递的顺序性

​	一致性问题

​		同一份消息，有的消费成功，有的消费失败



2、保证消息队列的高可用

​	rabbitMQ（非分布式）:

​		普通集群模式：

​			只有一个节点拥有元数据和实际数据，其他节点只拥有元数据

​		镜像集群模式：

​			所有节点都拥有所有的数据

​	kafka(分布式的)



3、如何保证消息不被重复消费（如何保证消息的幂等性）？

​	幂等：一条数据出现两次，数据库中只出现了一次，这就保证了幂等性



4、保证MQ消息的可靠性？保证消息不丢失

​	rabbitmq消息丢失：

​		1、写消息的过程中，因为网络传输问题，或其他问题，rabbitMq没保存成功

​			 1.消息事务：是同步的（会阻塞）

​			 2.confirm机制（常用）：

​		2、rabbitMq收到消息，放到内存中，rabbitmq挂了，内存中的数据丢了

​			   开启rabbitMq 持久化

​		3、消费者收到消息，没来得及处理，自己挂了，rabbitmq认为已经处理完了

​				消费者的autoAck 模式（基本不用，自己去确定消息是否处理完）

​	kafka数据丢失：

​		1、写消息的过程中，因为网络传输问题，或其他问题，kafka没保存成功

​			 ask=all ,没条数据写入到所有的replica之后，才能认为是写成功了

​		     retries=MAX(很大的一个值),写入失败，就无限重试

​		2、kafka收到消息，放到leader中，leader没来得及把数据同步到follower，leader挂了,将follwer切换为leader，数据丢失

​				给这个topic设置replication.factor参数：这个值必须大于1，要求每个partition至少要有两个副本 

​		3、消费者收到消息，没来得及处理，自己挂了，kafka认为已经处理完了

​				消费者会自动提交offset,关闭offset，手动提交offset

5、保证消息的顺序性

​		rabbit：一个queue,多个consumer 会出现消息错乱

​				每个消费者一个队列

​		kafka：一个topic，一个partition。一个consumer，内部多线程  错乱

​				多线程处理之前，使用一个内存队列暂存数据，

6、如何解决消息队列延时，过期失效的问题？队列满了的处理方法，积压消息太多，咋办



## rabbitMq



ActiveMQ:

1、activeMQ的通信方式

​	publish/subscribe  发布订阅

​	p2p

2、active消息丢失

​	publish/subscribe

​		接收不到消息就没了

​		不丢失：持久订阅

​	p2p	

​		消息发送不成功保存到active服务器，直到有消费者消费

3、消费者重复消费

​	在业务端加张表，存放消息是否执行成功，消费之前，先判断是否已经消费





1、服务器宕机了怎么办

​	非持久化消息存在内存中，持久化消息存在文件

​	尽量不要使用非持久化消息，要用，将临时文件尽可能的调大

2、怎么防止丢消息

​	使用持久化消息，

​	非持久化消息及时处理

​	启动事务

3、持久化消息比较慢

​	非持久化消息都是异步发送的，持久化消息是同步发送的

​	开启事务的情况下，消息都是异步发送的，

​	建议开启事务

4、消息不均匀消费

​	prefetch机制：消费者获取消息时，是一次获取prefetch的数量的消息个数

​	prefetch：1

5、怎么设置 消息处理失败，不被服务器删除，还能被其他消费者处理

​		关闭Auto_AcknowLedge，将ack由程序自己处理

​	

Kafka

----------------------------------------------------------------------------------------------------

# Redis



1 redis 线程模型

​	基于socket 模型  IO多路复用技术  队列  事件分派器    事件处理器

2、为什么 redis 单线程模型效率高

​	纯内存操作

​	核心是基于非阻塞的IO多路复用技术

​		单线程避免了多线性频繁切换上下文问题



3、redis 过期策略， LRU算法

​	定期删除

​	惰性删除



​	内存淘汰机制：

​		allkeys-Lru(常用)

​		allkeys-random (随机)

4、保证redis 高并发 高可用



redis 不能支持高并发的瓶颈： 是单机的



redis要支撑超过10万+的并发，怎么办

​	读写分离 （读多写少） ： 主从架构



redis Replication: redis 复制





redis 全量复制 ， 增量复制



redis 不可用（主从架构）

​	master node 死了，没办法写数据

redis 高可用（故障转移，主备切换）



sentinal node(哨兵)  作用：

​	集群监控

​	消息通知

​	故障转移

​	配置中心



quorum = 1 , 几个哨兵认为master node 宕机

majority:  大多数哨兵是运行的（多于总哨兵的的一半）

最少quorum  个哨兵认为master宕机了，且 majority个哨兵工作，才可以进行故障转移



redis 数据丢失问题:



redis 脑裂问题：

​	master主节点因为网络问题出现了异常,但实际上master还运行着，哨兵认为主节点宕机了，然后把一个slaveNode 改为master node，这个时候会出现两个 master 



解决异步复制和脑裂造成的数据丢失

​	min-slaves-to-write 1

​	min-slaves-max-lag 10

​	至少有1个slave，数据复制和同步的延迟不能超过10s，

​	如果所有slave。数据复制和同步超过10s，master就不再接收任何请求



sdown（主观宕机）：有一个哨兵认为master宕机

odown（客观宕机）：有quorum数量的哨兵都认为master 宕机





redis cluster（多master  + 读写分离 + 高可用）:

​	可以支撑N个redis master Node ，每个master 可以挂载多个 slave node

​	读写分离架构： 对于每个master，写就写到master， 读从 master对于的slave 中读

​	高可用：如果master挂了，自动将某个slave转换为maseter



redis cluser, replication, sentinal

​	单机： 数据量少

​	replication: 一个master，多个slave，搭建一个sentinal集群，保证架构高可用

​	cluster： 海量数据+高并发+高可用



## Redis面试

1、redis 优缺点：

​	redis 是一个 key-value 类型的内存数据库，操作在内存中进行，定期通过异步操作把数据flush到硬盘

​	每秒 10万次读写操作

​	支持多种数据结构， 单个value的最大限制是10G

​	数据库容量受到物理内存的限制，不能用作海量数据的高性能读写

​	适合数据量较小的高性能操作和运算



2、Redis 与 memcached 相比有哪些优势？  

​	mc所有的值均为简单字符串， redis 支持多种数据类型

​	redis的速度比mc 快

​	redis可以持久化数据

3、redis 的淘汰策略：

​	allkeys-Lru（LRU）: 尝试回收最少使用键，

​	volatile-Lru(LRU): 尝试回收最少使用的键，仅限在过期集合的键

​	allkeys-random: 随机回收键

4、redis为什么把数据存放到内存

​	为了最快的读写速度，通过异步的方式将数据写入磁盘，

5、redis的集群方案

​	codis

​	2、

6、Redis 集群方案什么情况下会导致整个集群不可用  

​	A,B,C 三个节点的集群，在没有复制模型的情况下，B挂了，



7、如何保证redis 中的数据都是热点数据

​	redis数据集到达一定的数量时，会实行数据淘汰策略

8、redis 适合的场景

​	会话缓存，队列， 排行榜/计数器, 发布/订阅 

9、 redis的主从复制模型是什么样的？

​	每个节点都有 N-1 个复制品，保证大部分节点挂了，集群仍然可用

10、 redis 事务

​	事务是一个单独的隔离操作，事务中的所有命令都会序列化，顺序执行，

​	事务在执行过程中，不会被其他请求打断

11、redis 的内存优化

​	尽可能的使用散列表，散列表使用的内存很小

12、redis的分布式锁

​	用setnx 抢锁，抢到之后，用expire 给锁设置过期时间

​	应该  把setnx 和expire 合成一条指令运行

13、什么是缓存穿透？如何避免，什么是缓存雪崩？如何避免?

​	缓存穿透：根据key查value。如果故意查询不存在的key，请求量很大，这就叫缓存穿透

​	穿透避免:

​		对查询结果为空的情况也进行缓存

​		对一定不存在的key进行过滤

​	缓存雪崩：缓存服务器重启，或者大量缓存几种在某一个时间段失效，在这段时间，会给后台系统造成很大的压力

​	雪崩避免：

​		缓存服务器失效后，通过加锁或者队列的方式，控制读数据库写缓存的线程数量

​		做二级缓存

​		不同的key，设置不同的过期时间

14、redis和memcached 的区别，为啥高并发下有时单线程的redis比多线程的memcached效率高

​	mc 可以缓存图片和视频，rd支持更多的数据结构

​	rd使用虚拟内存，rd可持久化和aof灾难恢复，rd 通过主从支持数据备份

​	rd可做消息队列

​	mc多线程模型引入了缓存一致性和锁，加锁带来了性能损耗

15、redis持久化，优缺点

​	RDB：在不同时间点将redis的数据生成快照同步到磁盘

​		内存到硬盘的快照，定期更新

​		缺点：耗时，耗性能，易丢失数据

​	AOF：将所有执行过的指令都记录下来，在下次redis重启时，去执行指令  （写日志）

​		缺点：体积大，恢复速度慢

​	rewrite： 可以对aof进行优化

​	bgsave指令，做镜像全量的持久化，aof做增量持久化

​	优先使用aof来恢复内存，没有，使用rdb

16、redis高可用

​		redis 哨兵和复制

​		哨兵：管理redis服务器，提供监控，提醒、自动的故障转移的功能

​		复制：让一个redis服务器可以配备多个备份服务器

17、redis 哨兵的主要功能

​	集群监控

​	消息通知

​	故障转移

​	配置中心

18、redis 哨兵的高可用

​	主节点故障，redis Sentinel 自动完成故障发现和转移，并通知应用方

19、redis 主从复制，哨兵，集群的区别

​	主从：读写分离，备份，一个master 多个slaves

​	哨兵：监控，自动转移

​	集群：将数据分配到多台服务器



------------------------------------------------------------------------------------------





# JAVA相关

## java

1、面向对象的三大特性

​	封装

​		把对象的属性私有化，提供可被访问的属性方法

​	多态

​		程序中使用的引用变量和引用变量的方法，是在程序运行期间才能确定

​	继承

​		使用已存在的类为基础，创建新的类

2、 == 和 equals

​	==: 判断两个对象的地址是否相等，即判断两个对象是否是同一个对象

​		基本类型 == 比较的是值，引用类型 == 比较的是内存地址

​	equals: 判断两个对象是否相等

​		类没有覆盖equals： 等价 ==

​		类覆盖了equals:  两个对象的内容是否相等

3、内存模型及分区，

​	堆： 对象

​		初始化的对象，成员变量，对象实例和数组

​	栈： 引用

​		栈帧组成，栈帧存储 局部变量，操作数栈，方法出口

​	方法区： 常量池

​		主要存储类信息，常量池，编译后的字节码

​	本地方法栈：

​		Native方法

​	程序计数器：

​		当前线程的执行行号

4、堆里面的分区：eden，survival（from to），老年代

​	java8 取消了永久代，采用 metaspace

​	新生代：包含eden 和survivor区。survivor区分为 from 和to 

​	老年区：多次Gc后，仍然活着的数据，会进入老年代

​	==jvm内存不够，触发 full gc, 清理老年代==

​	==新生区满了，触发yGC，把活的对象放到survival，进行垃圾清理，一般 把eden 全部清空，整理内存==

5、GC的三种收集算法

​	标记清除：

​		先标记，标记完毕后再清除， 效率不高，会产生碎片

​	标记整理：

​		标记完毕后，让所有的存活对象往一端移动

​	复制算法（YGC）：

​		分为8:1 的eden 区和Sruvivor区

​		先把存活的对象移到survival区，然后进行垃圾清理

6、Minor GC 和full Gc 的发生场景

​	MGC：新生代内存不够用的时候，也叫YGC

​	FGC: jvm内存不够用的时候

7、类的双亲委派机制

​	类加载加载类时，先由它的父亲去加载，如果父类加载不到，再有自己加载

8、什么是类加载器，有哪些类加载器

​	类加载器：通过类的全限定名获取该类的二进制字节流的代码

​	启动类加载器（bootstrap）：

​		加载java核心类库，

​	扩展类加载器（extensions）：

​		加载java扩展类，

​	系统类加载器（system）：

​		根据类路径（classPath）加载java类，java应用的类一般都是由它加载

​		ClassLoader.getSystemClassLoader

​	自定义类加载器

9、java内存分配与回收策略

​	对象优先在eden区分配

​	大对象直接进入老年代

​	长期存活的对象直接进入老年代

​	

## IO

阻塞IO

​	读写数据过程中会发生堵塞现象

非阻塞IO

​	读写数据过程中不会发生堵塞现象，如果数据没有准备好，则再次发送请求

多路复用IO

​	一个线程不断轮询多个socket状态，只有socket真正有读写事件，才真正调用实际IO进行读写操作







## Zookeeper

1、zk是什么

​	zk是分布式应用协调服务，

2、zk的功能

​	文件系统

​	通知机制



3、zk的文件系统

​	为了保证搞吞吐量和低延迟，在内存中维护了树状的目录结构，

​	缺点：不能存放大量的数据



CSRF：跨站请求伪造









## 乐观锁和悲观锁

悲观锁（独占）：资源每次只给一个线程使用，其他线程堵塞，用完释放锁

乐观锁：使用读多写少的情况。提高吞吐量（CAS算法）



### 自旋锁：

自旋锁原理：

​	持有锁的线程在很短的时间释放锁，等待竞争锁的线程不需要阻塞挂起，只需要等待持有锁的资源释放锁

​	后，立即获得锁。避免用户线程和内核的切换消耗
优缺点:

​	减少线程的阻塞，对于锁竞争不激烈，用锁时间短的代码性能提升很大

目的：

​	占着cpu资源不放，等待获得锁进行处理

### Synchronized 同步锁

独占式悲观锁，可重入





非公平锁：先到先得的规则

公平锁：直接尝试获取锁，获取不到，到队尾等待



ReentrantLock 和synchronized

1、ReentrantLock 通过方法 lock()与 unlock()来进行加锁与解锁操作，

 	synchronized ： JVM 自动解锁机制，

​	 ReentrantLock 加锁后需要手动进行解锁。使用 ReentrantLock 必须在 finally 控制块中进行解锁操作。

2、ReentrantLock 相比 synchronized 的优势是可中断、公平锁、多个锁



Semaphore 信号量

​	基于计数的信号量，

readWriteLock 读写锁

​	

锁的四种状态

​	无锁、偏向锁、轻量级锁、重量级锁

偏向锁：

​	某个线程获得锁后，会消除这个线程重入（cas）的开销

​	目的：在多线程竞争的情况下减少不必要的轻量级锁执行路径

重量级锁（mutex lock）：

​	通过对象内部的监视器锁（monitor）实现的

轻量级锁：

​	在没有多线程竞争的前提下，减少重量级锁的性能消耗

​	适用于 线程交替执行的同步块，







## Spring

beandefinition:描述了bean的配置信息

BeanDefinitionRegistry： 提供了向容器手工注册 BeanDefinition 对象的方法。

BeanFactory：getBean(String beanName)，该方法从容器中 返回特定名称的 Bean



RPC（remote Procedure call） 远程过程调用

​	调用远程计算机上的服务，就像调用本地服务一样



HTTP原理：

​	无状态：浏览器和服务器直接不需要建立持久的连接，

​	一个请求一个响应，连接关闭



# 日志：

## slf4j

​	是一种规则（接口），需要搭配其他日志实现框架使用

## Log4j

​	apache的日志实现框架

## Logback（日志实现）

​	实现了简单的slf4j



# 消息队列

## kafka

​	高吞吐量、分布式、发布、订阅的消息系统



## RabbitMq

​	erlang语言开发





# 数据库

1、数据库存储引擎

Mylsam

​	mysql 默认的引擎，读取操作很快，插入和更新需要锁表，效率低

​	不支持事务，

InnoDB

​	底层存储结构：b+树

InnoDB使用场景：

​	经常更新的表，适合处理多重并发的更新请求

​	支持事务			



数据库事务

​	原子性（Atomicity）: 要么都执行，要么都不执行

​	一致性(Consistency)

​		事务完成时，数据必须是一致的

​	隔离性(Isolation)

​		对数据进行修改的并发事务，彼此是隔离的

​	永久性(Durability)

​		事务完成后，对数据库的修改永久保持，





# 分布式缓存：

### 缓存雪崩：

定义：缓存失效，大量查缓存的请求去查数据库

解决办法：

​	并发量不大的情况，加锁排队

​	为key设置不同的缓存过期时间

​	给缓存数据增加对于的缓存标记，缓存标记失效则更新数据缓存

### 缓存穿透

定义：查数据库中不存在的数据

解决办法：

​	对查询结果进行缓存

​	布隆过滤器

​		对所有可能存在的数据hash到一个足够大的bitmap中，不存在的数据会被bitmap拦截

### 缓存预热

​	系统上线，将相关的缓存数据直接加载到缓存系统

### 缓存更新

​	定期清理过期缓存

​	请求过来，先判断是否过期，过期则去数据库查并更新缓存

