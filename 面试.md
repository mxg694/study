

# 视频观看

尚硅谷 周阳 面试  第二季  --58集

# 消息队列

1、为什么使用消息队列，消息队列的优缺点，kafka,activemq, rabbitmq,rocketmq

都有什么区别，适合那些场景

为什么：

​	解耦

​	异步

​	削峰

缺点： 

​	系统可用性降低：

​		MQ故障

​	系统复杂性提高：

​		消息的重复性消费，消息丢失。消息传递的顺序性

​	一致性问题

​		同一份消息，有的消费成功，有的消费失败



2、保证消息队列的高可用

​	rabbitMQ（非分布式）:

​		普通集群模式：

​			只有一个节点拥有元数据和实际数据，其他节点只拥有元数据

​		镜像集群模式：

​			所有节点都拥有所有的数据

​	kafka(分布式的)



3、如何保证消息不被重复消费（如何保证消息的幂等性）？

​	幂等：一条数据出现两次，数据库中只出现了一次，这就保证了幂等性



4、保证MQ消息的可靠性？保证消息不丢失

​	rabbitmq消息丢失：

​		1、写消息的过程中，因为网络传输问题，或其他问题，rabbitMq没保存成功

​			 1.消息事务：是同步的（会阻塞）

​			 2.confirm机制（常用）：

​		2、rabbitMq收到消息，放到内存中，rabbitmq挂了，内存中的数据丢了

​			   开启rabbitMq 持久化

​		3、消费者收到消息，没来得及处理，自己挂了，rabbitmq认为已经处理完了

​				消费者的autoAck 模式（基本不用，自己去确定消息是否处理完）

​	kafka数据丢失：

​		1、写消息的过程中，因为网络传输问题，或其他问题，kafka没保存成功

​			 ask=all ,没条数据写入到所有的replica之后，才能认为是写成功了

​		     retries=MAX(很大的一个值),写入失败，就无限重试

​		2、kafka收到消息，放到leader中，leader没来得及把数据同步到follower，leader挂了,将follwer切换为leader，数据丢失

​				给这个topic设置replication.factor参数：这个值必须大于1，要求每个partition至少要有两个副本 

​		3、消费者收到消息，没来得及处理，自己挂了，kafka认为已经处理完了

​				消费者会自动提交offset,关闭offset，手动提交offset

5、保证消息的顺序性

​		rabbit：一个queue,多个consumer 会出现消息错乱

​				每个消费者一个队列

​		kafka：一个topic，一个partition。一个consumer，内部多线程  错乱

​				多线程处理之前，使用一个内存队列暂存数据，

6、如何解决消息队列延时，过期失效的问题？队列满了的处理方法，积压消息太多，咋办



## rabbitMq



ActiveMQ:

1、activeMQ的通信方式

​	publish/subscribe  发布订阅

​	p2p

2、active消息丢失

​	publish/subscribe

​		接收不到消息就没了

​		不丢失：持久订阅

​	p2p	

​		消息发送不成功保存到active服务器，直到有消费者消费

3、消费者重复消费

​	在业务端加张表，存放消息是否执行成功，消费之前，先判断是否已经消费





1、服务器宕机了怎么办

​	非持久化消息存在内存中，持久化消息存在文件

​	尽量不要使用非持久化消息，要用，将临时文件尽可能的调大

2、怎么防止丢消息

​	使用持久化消息，

​	非持久化消息及时处理

​	启动事务

3、持久化消息比较慢

​	非持久化消息都是异步发送的，持久化消息是同步发送的

​	开启事务的情况下，消息都是异步发送的，

​	建议开启事务

4、消息不均匀消费

​	prefetch机制：消费者获取消息时，是一次获取prefetch的数量的消息个数

​	prefetch：1

5、怎么设置 消息处理失败，不被服务器删除，还能被其他消费者处理

​		关闭Auto_AcknowLedge，将ack由程序自己处理

​	

Kafka

----------------------------------------------------------------------------------------------------

# Redis



1 redis 线程模型

​	基于socket 模型  IO多路复用技术  队列  事件分派器    事件处理器

2、为什么 redis 单线程模型效率高

​	纯内存操作

​	核心是基于非阻塞的IO多路复用技术

​		单线程避免了多线性频繁切换上下文问题



3、redis 过期策略， LRU算法

​	定期删除

​	惰性删除



​	内存淘汰机制：

​		allkeys-Lru(常用)

​		allkeys-random (随机)

4、保证redis 高并发 高可用



redis 不能支持高并发的瓶颈： 是单机的



redis要支撑超过10万+的并发，怎么办

​	读写分离 （读多写少） ： 主从架构



redis Replication: redis 复制





redis 全量复制 ， 增量复制



redis 不可用（主从架构）

​	master node 死了，没办法写数据

redis 高可用（故障转移，主备切换）



sentinal node(哨兵)  作用：

​	集群监控

​	消息通知

​	故障转移

​	配置中心



quorum = 1 , 几个哨兵认为master node 宕机

majority:  大多数哨兵是运行的（多于总哨兵的的一半）

最少quorum  个哨兵认为master宕机了，且 majority个哨兵工作，才可以进行故障转移



redis 数据丢失问题:



redis 脑裂问题：

​	master主节点因为网络问题出现了异常,但实际上master还运行着，哨兵认为主节点宕机了，然后把一个slaveNode 改为master node，这个时候会出现两个 master 



解决异步复制和脑裂造成的数据丢失

​	min-slaves-to-write 1

​	min-slaves-max-lag 10

​	至少有1个slave，数据复制和同步的延迟不能超过10s，

​	如果所有slave。数据复制和同步超过10s，master就不再接收任何请求



sdown（主观宕机）：有一个哨兵认为master宕机

odown（客观宕机）：有quorum数量的哨兵都认为master 宕机





redis cluster（多master  + 读写分离 + 高可用）:

​	可以支撑N个redis master Node ，每个master 可以挂载多个 slave node

​	读写分离架构： 对于每个master，写就写到master， 读从 master对于的slave 中读

​	高可用：如果master挂了，自动将某个slave转换为maseter



redis cluser, replication, sentinal

​	单机： 数据量少

​	replication: 一个master，多个slave，搭建一个sentinal集群，保证架构高可用

​	cluster： 海量数据+高并发+高可用



## Redis面试

1、redis 优缺点：

​	redis 是一个 key-value 类型的内存数据库，操作在内存中进行，定期通过异步操作把数据flush到硬盘

​	每秒 10万次读写操作

​	支持多种数据结构， 单个value的最大限制是10G

​	数据库容量受到物理内存的限制，不能用作海量数据的高性能读写

​	适合数据量较小的高性能操作和运算



2、Redis 与 memcached 相比有哪些优势？  

​	mc所有的值均为简单字符串， redis 支持多种数据类型

​	redis的速度比mc 快

​	redis可以持久化数据

3、redis过期键删除策略

​	定时删除：设置键的同时，创建一个定时器

​	惰性删除：每次从键空间获取值时，先检查键是否过期

​	定期删除：每隔一段时间对库进行检查

3、redis 的淘汰策略：

​	volatile-lru: 共已设置过期时间的数据集中，挑选最近最少使用的数据淘汰

​	allkeys-lru: 从数据集中挑选最少使用的数据淘汰

4、redis为什么把数据存放到内存

​	为了达到最快的读写速度，并通过异步的方式将数据写入磁盘

​	不放入内存，磁盘IO会严重影响性能，内存越来越便宜

5、redis的集群方案

​	codis

6、Redis 集群方案什么情况下会导致整个集群不可用  

​	A,B,C 三个节点的集群，在没有复制模型的情况下，B挂了，



7、如何保证redis 中的数据都是热点数据

​	redis数据集到达一定的数量时，会实行数据淘汰策略

8、redis 适合的场景

​	会话缓存，队列， 排行榜/计数器, 发布/订阅 

9、 redis的主从复制模型是什么样的？

​	每个节点都有 N-1 个复制品，保证大部分节点挂了，集群仍然可用

10、 redis 事务

​	事务是一个单独个隔离操作，所有命令都会序列化，按顺序执行，不会被其他客户端请求打断

​	事务是一个原子操作，要么都成功，要么都失败

11、redis 的内存优化

​	尽可能的使用散列表，散列表使用的内存很小

12、redis的分布式锁

​	用setnx 抢锁，抢到之后，用expire 给锁设置过期时间

​	应该  把setnx 和expire 合成一条指令运行

13、什么是缓存穿透？如何避免，什么是缓存雪崩？如何避免?

​	缓存穿透：根据key查value。如果故意查询不存在的key，请求量很大，这就叫缓存穿透

​	穿透避免:

​		对查询结果为空的情况也进行缓存

​		对一定不存在的key进行过滤

​	缓存雪崩：缓存服务器重启，或者大量缓存几种在某一个时间段失效，在这段时间，会给后台系统造成很大的压力

​	雪崩避免：

​		缓存服务器失效后，通过加锁或者队列的方式，控制读数据库写缓存的线程数量

​		做二级缓存

​		不同的key，设置不同的过期时间

14、redis和memcached 的区别，为啥高并发下有时单线程的redis比多线程的memcached效率高

​	mc 可以缓存图片和视频，rd支持更多的数据结构

​	rd使用虚拟内存，rd可持久化和aof灾难恢复，rd 通过主从支持数据备份

​	rd可做消息队列

​	mc多线程模型引入了缓存一致性和锁，加锁带来了性能损耗

15、redis持久化，优缺点

​	RDB：在不同时间点将redis的数据生成快照同步到磁盘

​		内存到硬盘的快照，定期更新

​		缺点：耗时，耗性能，易丢失数据

​	AOF：将所有执行过的指令都记录下来，在下次redis重启时，去执行指令  （写日志）

​		缺点：体积大，恢复速度慢

​	rewrite： 可以对aof进行优化

​	bgsave指令，做镜像全量的持久化，aof做增量持久化

​	优先使用aof来恢复内存，没有，使用rdb

16、redis高可用

​		redis 哨兵和复制

​		哨兵：管理redis服务器，提供监控，提醒、自动的故障转移的功能

​		复制：让一个redis服务器可以配备多个备份服务器

17、redis 哨兵的主要功能

​	集群监控

​	消息通知

​	故障转移

​	配置中心

18、redis 哨兵的高可用

​	主节点故障，redis Sentinel 自动完成故障发现和转移，并通知应用方

19、redis 主从复制，哨兵，集群的区别

​	主从：读写分离，备份，一个master 多个slaves

​	哨兵：监控，自动转移

​	集群：将数据分配到多台服务器

4、redis是单线程的

​	redis利用队列技术精并发访问该为串行访问，消除了传统数据库串行控制的开销

9、redis集群原理

​	redis 哨兵 着眼高可用

​	redis 集群，着眼于扩展性。

10、redis的主从复制模型

​	每个节点都有N-1个复制品

11、redis之间如何复制

​	异步复制

13、redis事务相关的命令

​	multi, exec, discard, watch

15、大量key在同一时间过期，会出现什么情况

​	redis会出现卡顿情况，一般不会设置同一时间过期





## 布式缓存：

### 缓存雪崩：

定义：缓存失效，大量查缓存的请求去查数据库

解决办法：

​	并发量不大的情况，加锁排队

​	为key设置不同的缓存过期时间

​	给缓存数据增加对于的缓存标记，缓存标记失效则更新数据缓存

### 缓存穿透

定义：查数据库中不存在的数据

解决办法：

​	对查询结果进行缓存

​	布隆过滤器

​		对所有可能存在的数据hash到一个足够大的bitmap中，不存在的数据会被bitmap拦截

### 缓存预热

​	系统上线，将相关的缓存数据直接加载到缓存系统

### 缓存更新

​	定期清理过期缓存

​	请求过来，先判断是否过期，过期则去数据库查并更新缓存



------------------------------------------------------------------------------------------

# JAVA相关

## java

1、面向对象的三大特性

​	封装

​		把对象的属性私有化，提供可被访问的属性方法

​	多态

​		程序中使用的引用变量和引用变量的方法，是在程序运行期间才能确定

​	继承

​		使用已存在的类为基础，创建新的类

2、 == 和 equals

​	==: 判断两个对象的地址是否相等，即判断两个对象是否是同一个对象

​		基本类型 == 比较的是值，引用类型 == 比较的是内存地址

​	equals: 判断两个对象是否相等

​		类没有覆盖equals： 等价 ==

​		类覆盖了equals:  两个对象的内容是否相等

3、内存模型及分区，

​	堆： 对象

​		初始化的对象，成员变量，对象实例和数组

​	栈： 引用

​		栈帧组成，栈帧存储 局部变量，操作数栈，方法出口

​	方法区： 常量池

​		主要存储类信息，常量池，编译后的字节码

​	本地方法栈：

​		Native方法

​	程序计数器：

​		当前线程的执行行号

4、堆里面的分区：eden，survival（from to），老年代

​	java8 取消了永久代，采用 metaspace

​	新生代：包含eden 和survivor区。survivor区分为 from 和to 

​	老年区：多次Gc后，仍然活着的数据，会进入老年代

​	==jvm内存不够，触发 full gc, 清理老年代==

​	==新生区满了，触发yGC，把活的对象放到survival，进行垃圾清理，一般 把eden 全部清空，整理内存==

5、GC的三种收集算法

​	标记清除：

​		先标记，标记完毕后再清除， 效率不高，会产生碎片

​	标记整理：

​		标记完毕后，让所有的存活对象往一端移动

​	复制算法（YGC）：

​		分为8:1 的eden 区和Sruvivor区

​		先把存活的对象移到survival区，然后进行垃圾清理

6、Minor GC 和full Gc 的发生场景

​	MGC：新生代内存不够用的时候，也叫YGC

​	FGC: jvm内存不够用的时候

7、类的双亲委派机制

​	类加载加载类时，先由它的父亲去加载，如果父类加载不到，再有自己加载

8、什么是类加载器，有哪些类加载器

​	类加载器：通过类的全限定名获取该类的二进制字节流的代码

​	启动类加载器（bootstrap）：

​		加载java核心类库，

​	扩展类加载器（extensions）：

​		加载java扩展类，

​	系统类加载器（system）：

​		根据类路径（classPath）加载java类，java应用的类一般都是由它加载

​		ClassLoader.getSystemClassLoader

​	自定义类加载器

9、java内存分配与回收策略

​	对象优先在eden区分配

​	大对象直接进入老年代

​	长期存活的对象直接进入老年代

​	

## IO

阻塞IO

​	读写数据过程中会发生堵塞现象

非阻塞IO

​	读写数据过程中不会发生堵塞现象，如果数据没有准备好，则再次发送请求

多路复用IO

​	一个线程不断轮询多个socket状态，只有socket真正有读写事件，才真正调用实际IO进行读写操作



# 微服务

优势：	

​	降低复杂度： 将复杂业务拆分为单个服务

​	独立部署：微服务独立部署

​	容错 ： 限流、熔断降低错误导致对项目的危害

​	扩展： 

spring cloud 和 dubbo

​	支持协议

​		sc: http协议的rest api

​		db: rpc通信协议

​	



## Zookeeper

1、zk是什么

​	zk是分布式应用协调服务，

2、zk的功能

​	文件系统

​	通知机制



3、zk的文件系统

​	为了保证搞吞吐量和低延迟，在内存中维护了树状的目录结构，

​	缺点：不能存放大量的数据



CSRF：跨站请求伪造









## 乐观锁和悲观锁

悲观锁（独占）：资源每次只给一个线程使用，其他线程堵塞，用完释放锁

乐观锁：使用读多写少的情况。提高吞吐量（CAS算法）



### 自旋锁：

自旋锁原理：

​	持有锁的线程在很短的时间释放锁，等待竞争锁的线程不需要阻塞挂起，只需要等待持有锁的资源释放锁

​	后，立即获得锁。避免用户线程和内核的切换消耗
优缺点:

​	减少线程的阻塞，对于锁竞争不激烈，用锁时间短的代码性能提升很大

目的：

​	占着cpu资源不放，等待获得锁进行处理

### Synchronized 同步锁

独占式悲观锁，可重入





非公平锁：先到先得的规则

公平锁：直接尝试获取锁，获取不到，到队尾等待



ReentrantLock 和synchronized

1、ReentrantLock 通过方法 lock()与 unlock()来进行加锁与解锁操作，

 	synchronized ： JVM 自动解锁机制，

​	 ReentrantLock 加锁后需要手动进行解锁。使用 ReentrantLock 必须在 finally 控制块中进行解锁操作。

2、ReentrantLock 相比 synchronized 的优势是可中断、公平锁、多个锁



Semaphore 信号量

​	基于计数的信号量，

readWriteLock 读写锁

​	

锁的四种状态

​	无锁、偏向锁、轻量级锁、重量级锁

偏向锁：

​	某个线程获得锁后，会消除这个线程重入（cas）的开销

​	目的：在多线程竞争的情况下减少不必要的轻量级锁执行路径

重量级锁（mutex lock）：

​	通过对象内部的监视器锁（monitor）实现的

轻量级锁：

​	在没有多线程竞争的前提下，减少重量级锁的性能消耗

​	适用于 线程交替执行的同步块，







## Spring

beandefinition:描述了bean的配置信息

BeanDefinitionRegistry： 提供了向容器手工注册 BeanDefinition 对象的方法。

BeanFactory：getBean(String beanName)，该方法从容器中 返回特定名称的 Bean



RPC（remote Procedure call） 远程过程调用

​	调用远程计算机上的服务，就像调用本地服务一样



HTTP原理：

​	无状态：浏览器和服务器直接不需要建立持久的连接，

​	一个请求一个响应，连接关闭



# 日志：

## slf4j

​	是一种规则（接口），需要搭配其他日志实现框架使用

## Log4j

​	apache的日志实现框架

## Logback（日志实现）

​	实现了简单的slf4j



# 数据库

## mySql

1、数据库存储引擎

Mylsam

​	mysql 默认的引擎，读取操作很快，插入和更新需要锁表，效率低

​	不支持事务，

InnoDB

​	底层存储结构：b+树

InnoDB使用场景：

​	经常更新的表，适合处理多重并发的更新请求

​	支持事务			



数据库事务

​	原子性（Atomicity）: 要么都执行，要么都不执行

​	一致性(Consistency)

​		事务完成时，数据必须是一致的

​	隔离性(Isolation)

​		对数据进行修改的并发事务，彼此是隔离的

​	永久性(Durability)

​		事务完成后，对数据库的修改永久保持，





-------------------------------------------------------------------------------------------------------------

# 面试

## 基础

1.我是xxx工作xxx年， 先后在xxx公司工作，先后做过多少项目

2、简单介绍项目：

​     为了解决什么问题，开发了一套什么系统。该系统有哪些部分组成。

​     先介绍项目的整体架构，参与某个模块的开发， 说一下 这个模块的业务设计

3、java的专业技能

4、最擅长什么，说下

 	对xxx有所研究



1、java的跨平台原理：

​		java通过不同系统，不同版本，不同位数的java虚拟机（jvm）,来屏蔽不同的系统指令集差异，

​		而对外提供统一的接口（java API）.

​		简化：java 通过jvm来屏蔽不同系统指令集的差异，通过通用api开发程序

2、java 中 int数据 占几个字节：

​		int 占 4个字节，32位

​		boolean 占  1位

3、面向对象的特性

​	封装、多态、继承、抽象

​	封装：将对象封装成高度自治和相对封闭的个体，一个类，属性私有，提供get和set方法

​    抽象：找出事物的相似和共性之处，抽象出公共属性。

​	继承：父子关系

​	多态：

​		实现机制：编译期间不确定调用对象，运行期间才会确定

​	原则：回答抽象的问题的时候，要举例说明



4、基本数据类型 和  包装类型

​		8中基本数据类型

​		每个基本数据类型，都会一一对应包装类型

​		装箱和拆箱

​		装箱：基本数据类型 -》 包装类型

​		拆箱：包装类型 --》基本数据类型

​		基本数据类型，不具备面向对象的特性

5、== 和equals

​	== : 判断两个变量的值是否相等。 基本数据类型变量 ==比较值==，引用数据类型比较引用==内存的首地址==

​	equals: 比较两个对象长的是否一样

6、String 和StringBuilder, StringBuffer

​		String: ==内容不可变，String 底层使用了一个不可变的字符数组==

​		StringBuilder：内容可变，底层使用的是可变的字符数组，==线程不安全，效率快==

​		StringBuffer：内容可变，底层使用的是可变的字符数组，==线程安全==

7、java中的集合

​		Collection(key)

​			List:  有序，可重复（根据equals和hashcode 方法）。

​			Set:  无序，不可重复，

​		Map（key-value）

8、ArrayList  和 LinkedList

​	ArrayList：

​		底层使用的是数组（是一块地址连续的内存），查询快，插入删改慢

​	LinkedList:

​		底层使用的是链表（是一块地址不连续的内存），查询慢，插入删改快

9、hashMap 和hashTable

​	共同点： 都可以存储key-value 数据

​	不同点：

​		hashMap：

​			null 可以为key,线程不安全，效率高

​		hashTable:

​			null 不可以为key,线程安全，效率低

​		concurrentHashMap: 线程安全，效率相对较高

10、拷贝文件的工具类使用字节流还是字符流

​	字符流： 只能是文本

​	字节流： 二进制数组

11、线程的几种实现方式：

​		继承thread类：扩展性差

​		实现runnable接口

12、线程池的作用：

​		限定线程个数，不会导致由于线程过多，导致系统运行缓慢或崩溃

13、常用设计模式：

​		设计模式：解决特定问题的设计方法

​		单例：		

​		工厂：springIOC

​			对象的创建，交给一个工厂

​		代理：springAOP

14、http Get post	

​	相同：

​		都是http 请求方式，get -》获取资源  post->修改资源

​	不同:

​		get：

​			提交请求会在地址栏中显示

​			传输数据大小有限制

​			安全性低

​		post：

​			提交请求不会在地址栏中显示

​			传输数据大小没有限制

​			安全性高

15、Servlet

​	server applet: 

​		服务器端程序，交互式的浏览和修改数据，生成动态web内容

​	cookie 和session:

​		cookie:

​			客户端记录信息

​		session:

​			服务器端记录信息

16：MVC   model  view  controller

​	

数据库：

关系型数据库三范式：

​	一：表中每一列都不可分割

​	二：主键

​	三：外键

反三范式：

​	为了效率查询，设置重复字段



事务（ACID）：操作序列

​	原子性：操作不可分割，要么都成功，要么都失败

​	一致性：要么都成功，要么都失败，失败要回滚

​	隔离性：事务开始后，不能受其他事务干扰

​	持久性：事务开始后，不能终止





## 尚硅谷面试

volitle:

​	是java虚拟机提供的轻量级的同步机制

​	保证可见性

​		某个线程修改主内存变量的值，并推送到主内存，其他线程会把改变后的值同步过去

​	不保证原子性

​	禁止指令重排





JVM: java虚拟机

JMM:java 内存模型， 只是一种规范

主内存：计算机中的内存

（栈空间）自己的工作内存： 线程中的内存空间





多线程数据丢失问题

​	多个线程访问同一个共享资源，A获得资源，对数据进出操作，在把操作后的数据写入主内存时，

​	B线程获得资源，然后对数据进出操作，把操作后的数据写入到主内存

​	此时 A 获得资源，会继续之前未完成的操作，即把B操作后的数据覆盖掉。

​	此时，就发生了数据丢失情况





各个线程对主内存共享变量的操作：

​	各个线程各自拷贝到自己的工作内存进行操作，然后在写会主内存



原子性：

​	不可分割，完整性， 同时成功，同时失败

有序性：

​	

指令重排   数据依赖性

​	源代码-	编译器优化重排  指令并行的重排  内存系统的重排   最终执行的指令

​	

多线程环境中线程交替执行，由于编译器优化重排的存在，

两个线程中使用的遍历能否保持一致是不确定的，结果无法预测



instance = new A(); 可以分为下面三步



memory = allocate(); //1、分配对象内存空间

instance（memory）；//2、  初始化对象

instance = memory；//3、设置instance 指向刚分配的内存地址





cas 是一条cpu 并发原语

原语：执行必须是连续的，执行过程中不允许被中断



解决ABA问题：

​	原子引用       时间戳问题





java.util.ConcurrentModificationException  ArrayList 多线程报错



```
1、故障现象
     java.util.ConcurrentModificationException
2、导致现象
 
3、解决方案
 
4 优化建议
```

公平锁：多个线程按照申请锁的顺序来获取锁，类似 排队打饭

非公平锁：多个线程不是按照申请锁的顺序来获取锁，有可能造成==反转或饥饿现象==，优点：吞吐量高

可重入锁（递归锁）：线程可以进入任何一个它已经拥有的锁所同步着的代码块

自旋锁：尝试获取锁的线程不会立即堵塞，而是采用循环的方式尝试获取锁

​	好处：减少上下文切换的消耗，

​	缺点：循环消耗cpu

独占锁：

​	该锁只能被一个线程所有

共享锁：

​	该锁可被多个线程锁持有

CountDownLatch： 倒計時



Synchronized 和lock有什么区别

1、原始构成

​    	Synchronized 是关键字属于JVM方面， 使用的是monitor

​	      lock是一个具体类,是api层面的锁

2、使用方法

   Synchronized 不需要手动释放锁

​	lock 需要手动释放锁

3、等待是否可中断

​	Synchronized 不可中断

​	lock 可中断

4、加锁是否公平

​	Synchronized  非公平锁

​	lock 两者都可以

5、锁绑定多个条件condition

​	Synchronized  没有，要么随机唤醒一个，要么唤醒全部

​	lock 可以精确唤醒



线程池：

​	控制线程数量（最大并发数），线程复用，管理线程



线程池底层原理：

1.创建线程，等待任务

2.调用execute() 添加一个请求任务

​	当正在运行的线程小于corePoolSize, 马上创建线程进行这个任务

​	当 > corePoolSize , 将任务放入到队列

​	队列满了，且正在运行的数量小于maxpoolsize，创建非核心线程数立刻运行该任务

​	队列满了，且正在运行的线程数量大于或等于maxpoolsize，启动饱和拒绝策略

​	

3.线程完成任务，会从队列中取下一个任务

4.当一个线程无事可做超过一定时间

​	当前运行的线程数 >corePoolSize,线程会被停掉

​	线程池的所有任务完成，会收缩到corePoolSize大小



死锁：	

​	两个或两个以上线程在执行过程中，争抢资源造成的一种相互等待的现象





# JVM面试题

### 类加载子系统

1、双亲委派机制：

​	优势：避免类的重复加载，保护程序安全，防止核心api被随意篡改

2.为什么要自定义加载器：

​	隔离加载类

​	修改类加载方式

​	扩展加载源

​	防止源码泄露



### 栈面试：

1.栈溢出（statckoverflowError）

​	设置-Xss设置栈的大小； OOM

2.垃圾回收会涉及到虚拟机栈吗？

​	不会

3.方法内局部变量是否线程安全？ 

​		如果方法内局部变量==没有逃离方法的作用范围==（不 return）， 是线程的安全的





# Mybatis

#### mybatis在和 spring整合之后为什么失效

​	    因为mybatis和spring的集成包中扩展了一个类SqlSessionTemplate，这个类在spring容器启动的时候注入给了mapper，这个类代替了原来的 DefaultSqlSession，SqlSessionTemplate的所有查询方法不是直接查询，而是经过一个代理，代理对象增强了查询方法，注意是关闭了session