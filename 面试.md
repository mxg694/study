## 消息队列

1、为什么使用消息队列，消息队列的优缺点，kafka,activemq, rabbitmq,rocketmq

都有什么区别，适合那些场景

为什么：

​	解耦

​	异步

​	削峰

优缺点：

缺点： 

​	系统可用性降低：

​		MQ故障

​	系统复杂性提高：

​		消息的重复性消费，消息丢失。消息传递的顺序性

​	一致性问题

​		同一份消息，有的消费成功，有的消费失败



2、保证消息队列的高可用

​	rabbitMQ（非分布式）:

​		普通集群模式：

​			只有一个节点拥有元数据和实际数据，其他节点只拥有元数据

​		镜像集群模式：

​			所有节点都拥有所有的数据

​	kafka(分布式的)



3、如何保证消息不被重复消费（如何保证消息的幂等性）？

​	幂等：一条数据出现两次，数据库中只出现了一次，这就保证了幂等性



4、保证MQ消息的可靠性？保证消息不丢失

​	rabbitmq消息丢失：

​		1、写消息的过程中，因为网络传输问题，或其他问题，rabbitMq没保存成功

​			 1.消息事务：是同步的（会阻塞）

​			 2.confirm机制（常用）：

​		2、rabbitMq收到消息，放到内存中，rabbitmq挂了，内存中的数据丢了

​			   开启rabbitMq 持久化

​		3、消费者收到消息，没来得及处理，自己挂了，rabbitmq认为已经处理完了

​				消费者的autoAck 模式（基本不用，自己去确定消息是否处理完）

​	kafka数据丢失：

​		1、写消息的过程中，因为网络传输问题，或其他问题，kafka没保存成功

​			 ask=all ,没条数据写入到所有的replica之后，才能认为是写成功了

​		     retries=MAX(很大的一个值),写入失败，就无限重试

​		2、kafka收到消息，放到leader中，leader没来得及把数据同步到follower，leader挂了,将follwer切换为leader，数据丢失

​				给这个topic设置replication.factor参数：这个值必须大于1，要求每个partition至少要有两个副本 

​		3、消费者收到消息，没来得及处理，自己挂了，kafka认为已经处理完了

​				消费者会自动提交offset,关闭offset，手动提交offset

5、保证消息的顺序性

​		rabbit：一个queue,多个consumer 会出现消息错乱

​				每个消费者一个队列

​		kafka：一个topic，一个partition。一个consumer，内部多线程  错乱

​				多线程处理之前，使用一个内存队列暂存数据，